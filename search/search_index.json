{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>This is the project page of flooder, an easy-to-use Python package for constructing a lightweight simplicial complex (i.e., the FLood complex) on top of (low-dimensional) Euclidean point cloud data and subsequent persistent homology<sup>1</sup> (PH) computation. Algorithmically, flooder is designed to take full advantage of state-of-the-art GPU computing frameworks (via PyTorch) to enable computation of a filtered simplicial complex on millions of points in seconds. Based on the Flood complex, we use the awesome gudhi library for PH computation.</p>"},{"location":"#illustration","title":"Illustration","text":"<p>Below is an illustrative animation on how the (filtered) Flood complex is built (on a noisy sample of a figure-eight shape in 2D), starting from a collection of points and a Delaunay triangulation of a small subset of landmarks (in yellow). In short, a simplex of the Delaunay triangulation is added to the Flood complex at time \\(t\\geq 0\\), if it is fully covered by balls of radius \\(t\\), centered at all data points.</p>"},{"location":"#runtime-teaser","title":"Runtime teaser","text":"<p>Below you find a runtime comparison of computing zero-, one-, and two-dimensional Flood and Alpha PH on 1M points in 3D (using a NVIDIA H100 NVL GPU). The data used in this comparison is a synthetic (3D) swiss cheese created by uniformly drawing points in the unit cube and introducing a certain number of voids. Note that on point clouds of this size (in fact, even at much lower scale), computing Vietoris-Rips PH is intractable (beyond 0-dimensional features). The table lists runtime in seconds (for creating the filtered Flood and Alpha complexes and subsequent PH computation).</p> Complex  Runtime (in s) Alpha complex (via <code>gudhi.AlphaComplex</code>) 141.8 \\(\\pm\\) 1.5 Flood complex (via flooder) 1.4 \\(\\pm\\) 0.3 <p>Please see our <code>examples</code> folder in the flooder GitHub repository to run your own runtime comparison.</p> <p>Caution</p> <p>flooder is still under active development and it's usage API might change significantly over the next months.</p> <ol> <li> <p>Edelsbrunner, Letscher &amp; Zomorodian. Topological Persistence and Simplification. Discrete Comput Geom 28, 511\u2013533 (2002). DOI \u21a9</p> </li> </ol>"},{"location":"contributing/","title":"Contributing","text":"<p>Here's a step-by-step example of how to contribute to <code>flooder</code>.</p>"},{"location":"contributing/#fork-the-repository","title":"Fork the repository","text":"<p>On GitHub, click \"Fork\" to create your personal copy of the repository in your GitHub account, then    clone your fork. In the following, lets call the fork <code>flooder-devel</code>.</p> <pre><code>git clone https://github.com/rkwitt/flooder-devel.git\ncd flooder-devel\n</code></pre>"},{"location":"contributing/#add-upstream-remote","title":"Add upstream remote","text":"<pre><code>git remote add upstream https://github.com/plus-rkwitt/flooder.git   \n</code></pre>"},{"location":"contributing/#sync-your-local-main","title":"Sync your local main","text":"<p>Surely, if you just forked, everything will be in sync (but just to be sure :)</p> <pre><code>git checkout main\ngit fetch upstream\ngit rebase upstream/main\ngit push origin main\n</code></pre>"},{"location":"contributing/#create-a-feature-branch","title":"Create a feature branch","text":"<p>Next, we create a feature branch which will contain our adjustments/enhancements/etc.</p> <pre><code>git checkout -b fix-typos\n</code></pre>"},{"location":"contributing/#make-changes-and-commit","title":"Make changes and commit","text":"<p>Once you are done with your changes, commit.</p> <pre><code>git commit -a -m \"ENH: Fixed some typos.\"\n</code></pre> <p>What if <code>upstream/main</code> divereged in the meantime (e.g., a PR     got merged or so)?</p> <pre><code>git fetch upstream\ngit rebase upstream/main\n</code></pre> <p>Fix files in case of conflicts, then add them and continue the rebase.</p> <pre><code>git add &lt;file&gt;\ngit rebase --continue\n</code></pre>"},{"location":"contributing/#push-your-branch-to-your-fork","title":"Push your branch to your fork","text":"<pre><code>git push --force-with-lease origin fix-typos\n</code></pre>"},{"location":"contributing/#open-a-pr-on-github","title":"Open a PR on GitHub","text":"<p>Finally, create a pull request on GitHub.</p> <ul> <li>Navigate to your fork on GitHub.</li> <li>Click \"Compare &amp; pull request\".</li> <li>Submit the pull request to the upstream repository.</li> </ul> <p>PR's will be reviewed by the main developers of <code>flooder</code>, possibly commented, and then merged in case of no conflicts or concerns.</p>"},{"location":"contributing/#cleanup","title":"Cleanup","text":"<p>Once the PR is merged, we cleanup the branch in the forked repo.</p> <pre><code>git branch -d fix-typos\ngit push origin --delete fix-typos\n</code></pre>"},{"location":"examples/","title":"Examples","text":""},{"location":"examples/#flood-ph-of-noisy-torus-points","title":"Flood PH of noisy torus points","text":"<p>In the following example, we sample <code>n_pts=1000000</code> points from a noisy torus in 3D, then construct the Flood complex on top of <code>n_lms=1000</code> landmarks (see Illustration ) and compute persistent homology (up to dimension 3) using <code>gudhi</code> based on the constructed filtered Flood simplicial complex.</p> <pre><code>from flooder import (\n    generate_noisy_torus_points_3d, \n    flood_complex, \n    generate_landmarks)\n\nDEVICE = \"cuda\"\nn_pts = 1_000_000  # Number of points to sample from torus\nn_lms = 1_000      # Number of landmarks for Flood complex\n\npts = generate_noisy_torus_points_3d(n_pts).to(DEVICE)\nlms = generate_landmarks(pts, n_lms)\n\nstree = flood_complex(pts, lms, return_simplex_tree=True)\nstree.compute_persistence()\nph_diags = [stree.persistence_intervals_in_dimension(i) for i in range(3)]\n</code></pre> <p>Importantly, one can either call <code>flood_complex</code> with the already pre-selected (here via FPS) landmarks, or one can just specify the number of desired landmarks, e.g., via</p> <pre><code>stree = flood_complex(pts, n_lms, return_simplex_tree=True)\n</code></pre> <p>in which case FPS is called internally.</p>"},{"location":"install/","title":"Installation","text":""},{"location":"install/#environment-setup","title":"Environment setup","text":"<p>We recommend installing flooder in a clean new Anaconda environment as described below:</p> <pre><code>conda create -n flooder-env python=3.9 -y\nconda activate flooder-env\nconda install pip git -y\n</code></pre>"},{"location":"install/#via-pip-recommended","title":"Via Pip (recommended)","text":"<p>flooder is available on PyPi (here) and can be installed via:</p> <pre><code>pip install flooder\n</code></pre>"},{"location":"install/#development-installation","title":"Development installation","text":"<p>In case you want to contribute to flooder, clone the GitHub repo and run</p> <pre><code>git clone https://github.com/plus-rkwitt/flooder\ncd flooder\npip install -e .\n</code></pre> <p>In case you do not want to install anything, you can also execute examples or tests from within the checked-out folder by specifying <code>PYTHONPATH</code>as</p> <pre><code>git clone https://github.com/plus-rkwitt/flooder\ncd flooder\nPYTHONPATH=. python examples/example_01_cheese_3d.py\n</code></pre>"},{"location":"install/#gpu-requirements","title":"GPU requirements","text":"<p>Our implementation relies heavily on custom Triton kernels (although we support CPU computation as well) for maximum performance. According to the official Triton compatibility page, you need a NVIDIA GPU with compute capabilty (check here) of at least 8.0 (e.g., GTX 3080, etc.).</p>"},{"location":"reference/core/","title":"Core","text":""},{"location":"reference/core/#flooder.core","title":"flooder.core","text":"<p>Implementation of flooder core functionality.</p> <p>Copyright (c) 2025 Paolo Pellizzoni, Florian Graf, Martin Uray, Stefan Huber and Roland Kwitt SPDX-License-Identifier: MIT</p>"},{"location":"reference/core/#flooder.core.flood_complex","title":"flood_complex","text":"<pre><code>flood_complex(\n    points: Tensor,\n    landmarks: Union[int, Tensor],\n    max_dimension: Union[None, int] = None,\n    points_per_edge: Union[None, int] = 30,\n    num_rand: int = None,\n    batch_size: Union[None, int] = 256,\n    use_triton: bool = True,\n    return_simplex_tree: bool = False,\n    fps_h: Union[None, int] = None,\n    start_idx: Union[int, None] = 0,\n) -&gt; Union[dict, gudhi.SimplexTree]\n</code></pre> <p>Constructs a Flood complex from a set of witness points and landmarks.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>Tensor</code> <p>A (N, d) tensor containing witness points used as sources in the flood process.</p> required <code>landmarks</code> <code>Union[int, Tensor]</code> <p>Either an integer indicating the number of landmarks to randomly sample from <code>points</code>, or a tensor of shape (N_l, d) specifying explicit landmark coordinates.</p> required <code>max_dimension</code> <code>Union[None, int]</code> <p>The top dimension of the simplices to construct. Defaults to None resulting in the dimension of the ambient space.</p> <code>None</code> <code>points_per_edge</code> <code>Union[None, int]</code> <p>Specifies resolution on simplices used for computing filtration values. Tradeoff in accuracy vs. speed. Defaults to 30.</p> <code>30</code> <code>num_rand</code> <code>Union[None, int]</code> <p>If specified, filtration values are computed from a fixed number of random points per simplex. Defaults to None.</p> <code>None</code> <code>batch_size</code> <code>int</code> <p>Number of simplices to process per batch. Defaults to 32.</p> <code>256</code> <code>use_triton</code> <code>bool</code> <p>If True, Triton kernel is used. Defaults to True.</p> <code>True</code> <code>fps_h</code> <code>Union[None, int]</code> <p>h parameter (depth of kdtree) that is used for farthest point sampling to select the landmarks. If None, then h is selected based on the size of the point cloud. Defaults to None.</p> <code>None</code> <code>return_simplex_tree</code> <code>bool</code> <p>I true, a gudhi.SimplexTree is returned, else a dictionary. Defaults to False</p> <code>False</code> <code>start_idx</code> <code>int | None</code> <p>If provided, FPS starts from this index in the point cloud. If not, the start index will be randomly picked from the point cloud. Defaults to 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>Union[dict, SimplexTree]</code> <p>Union[dict, gudhi.SimplexTree] Depending on the return_simplex_tree argument either a gudhi.SimplexTree or a dictionary is returned, mapping simplices to their estimated covering radii (i.e., filtration value). Each key is a tuple of landmark indices (e.g., (i, j) for an edge), and each value is a float radius.</p>"},{"location":"reference/core/#flooder.core.generate_grid","title":"generate_grid","text":"<pre><code>generate_grid(\n    n: int, dim: int, device: device\n) -&gt; Tuple[\n    torch.Tensor, List[torch.Tensor], List[torch.Tensor]\n]\n</code></pre> <p>Generates a grid of points on the unit simplex based on the number of points per edge.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of points per edge.</p> required <code>dim</code> <code>int</code> <p>Dimension of the simplex.</p> required <code>device</code> <code>device</code> <p>Device to create the tensors on.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[Tensor, List[Tensor], List[Tensor]]</code> <p>grid (torch.Tensor):     Tensor of shape (C, dim + 1), containing the grid points (coordinate weights). vertex_ids (list of torch.Tensor):     A list of tensors, each containing the vertex indices for each face. face_ids (list of torch.Tensor):     A list of tensors, each containing the face indices for each face.</p>"},{"location":"reference/core/#flooder.core.generate_landmarks","title":"generate_landmarks","text":"<pre><code>generate_landmarks(\n    points: Tensor,\n    n_lms: int,\n    fps_h: Union[None, int] = None,\n    start_idx: Union[int, None] = None,\n) -&gt; torch.Tensor\n</code></pre> <p>Selects landmarks using Farthest-Point Sampling (bucket FPS).</p> <p>This method implements a variant of Farthest-Point Sampling from here.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>Tensor</code> <p>A (P, d) tensor representing a point cloud. The tensor may reside on any device (CPU or GPU) and be of any floating-point dtype.</p> required <code>n_lms</code> <code>int</code> <p>The number of landmarks to sample (must be &lt;= P and &gt; 0).</p> required <code>fps_h</code> <code>Union[None, int]</code> <p>h parameter (depth of kdtree) that is used for farthest point sampling to select the landmarks. If None, then h is selected based on the size of the point cloud. Defaults to None.</p> <code>None</code> <code>start_idx</code> <code>int | None</code> <p>If provided, the sampling starts from this index in the point cloud. If not, the start index will be randomly picked from the point cloud.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tensor</code> <p>torch.Tensor: A (n_l, d) tensor containing a subset of the input <code>points</code>, representing the sampled landmarks. Returned tensor is on the same device and has the same dtype as the input.</p>"},{"location":"reference/core/#flooder.core.generate_uniform_weights","title":"generate_uniform_weights","text":"<pre><code>generate_uniform_weights(num_rand, dim, device)\n</code></pre> <p>Generates num_rand points from a uniform distribution on the unit simplex.</p> <p>Parameters:</p> Name Type Description Default <code>num_rand</code> <code>int</code> <p>Number of random points to generate.</p> required <code>dim</code> <code>int</code> <p>Dimension of the simplex.</p> required <code>device</code> <code>device</code> <p>Device to create the tensor on.</p> required <p>Returns:     torch.Tensor:         A tensor of shape [num_rand, dim + 1] containing the random points         (coordinate weights).</p>"},{"location":"reference/io/","title":"Utils","text":""},{"location":"reference/io/#flooder.io","title":"flooder.io","text":"<p>IO functionality (for consistent saving).</p> <p>Copyright (c) 2025 Paolo Pellizzoni, Florian Graf, Martin Uray, Stefan Huber and Roland Kwitt SPDX-License-Identifier: MIT</p>"},{"location":"reference/io/#flooder.io.save_to_disk","title":"save_to_disk","text":"<pre><code>save_to_disk(\n    obj: Any,\n    path: Union[str, Path],\n    metadata: bool = True,\n    overwrite: bool = False,\n) -&gt; None\n</code></pre> <p>Save an object to disk using <code>torch.save</code>.</p> <p>This function saves any Python object to a specified path. If the object is a dictionary and <code>metadata=True</code>, a <code>_meta</code> entry is added to the copy with timestamp and key information. If the file already exists and <code>overwrite=False</code>, an error is raised.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>The Python object to save (e.g., a tensor, dictionary, or model).</p> required <code>path</code> <code>Union[str, Path]</code> <p>The file path where the object will be saved.</p> required <code>metadata</code> <code>bool</code> <p>Whether to include metadata in the saved file (only applicable if <code>obj</code> is a dictionary). Defaults to True.</p> <code>True</code> <code>overwrite</code> <code>bool</code> <p>Whether to overwrite the file if it already exists. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>FileExistsError</code> <p>If the file already exists and <code>overwrite</code> is False.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"reference/synthetic_data_generators/","title":"Synthetic data generators","text":""},{"location":"reference/synthetic_data_generators/#flooder.synthetic_data_generators","title":"flooder.synthetic_data_generators","text":"<p>Implementation of synthetic data generators.</p> <p>Copyright (c) 2025 Paolo Pellizzoni, Florian Graf, Martin Uray, Stefan Huber and Roland Kwitt SPDX-License-Identifier: MIT</p>"},{"location":"reference/synthetic_data_generators/#flooder.synthetic_data_generators.generate_annulus_points_2d","title":"generate_annulus_points_2d","text":"<pre><code>generate_annulus_points_2d(\n    n: int = 1000,\n    center: tensor = torch.tensor([0.0, 0.0]),\n    radius: float = 1.0,\n    width: float = 0.2,\n    seed: int = None,\n) -&gt; torch.tensor\n</code></pre> <p>Generate 2D points uniformly distributed in the region between two concentric circles.</p> <p>In particulr, points are sampled uniformly within a ring defined by an outer <code>radius</code> and an inner radius of <code>radius - width</code>, centered at a specified 2D location.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of points to generate. Defaults to 1000.</p> <code>1000</code> <code>center</code> <code>Tensor</code> <p>Center of the annulus as a tensor of shape (2,). Defaults to [0.0, 0.0].</p> <code>tensor([0.0, 0.0])</code> <code>radius</code> <code>float</code> <p>Outer radius of the annulus. Must be positive. Defaults to 1.0.</p> <code>1.0</code> <code>width</code> <code>float</code> <p>Thickness of the annulus. Must be positive and less than <code>radius</code>. Defaults to 0.2.</p> <code>0.2</code> <code>seed</code> <code>int</code> <p>Random seed for reproducibility. If None, randomness is not seeded.</p> <code>None</code> <p>Returns:</p> Type Description <code>tensor</code> <p>torch.Tensor: A tensor of shape (N, 2) containing the sampled 2D points.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; center = torch.tensor([0.0, 0.0])\n&gt;&gt;&gt; points = generate_annulus_points_2d(n=500, center=center, radius=1.0, width=0.3, seed=42)\n&gt;&gt;&gt; points.shape\ntorch.Size([500, 2])\n</code></pre>"},{"location":"reference/synthetic_data_generators/#flooder.synthetic_data_generators.generate_figure_eight_points_2d","title":"generate_figure_eight_points_2d","text":"<pre><code>generate_figure_eight_points_2d(\n    n: int = 1000,\n    r_bounds: Tuple[float, float] = (0.2, 0.3),\n    centers: Tuple[\n        Tuple[float, float], Tuple[float, float]\n    ] = ((0.3, 0.5), (0.7, 0.5)),\n    noise_std: float = 0.0,\n    noise_kind: Literal[\"gaussian\", \"uniform\"] = \"gaussian\",\n    seed: int = None,\n) -&gt; torch.tensor\n</code></pre> <p>Generate 2D points uniformly sampled in a figure-eight shape, with optional noise.</p> <p>This function samples <code>n_samples</code> points distributed across two circular lobes (forming a figure-eight shape) centered at specified coordinates. Optionally, isotropic Gaussian or uniform noise can be added to the coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of 2D points to generate. Defaults to 1000.</p> <code>1000</code> <code>r_bounds</code> <code>Tuple[float, float]</code> <p>Tuple specifying the minimum and maximum radius for sampling within each lobe. Defaults to (0.2, 0.3).</p> <code>(0.2, 0.3)</code> <code>centers</code> <code>Tuple[Tuple[float, float], Tuple[float, float]]</code> <p>Coordinates of the centers of the two lobes. Defaults to ((0.3, 0.5), (0.7, 0.5)).</p> <code>((0.3, 0.5), (0.7, 0.5))</code> <code>noise_std</code> <code>float</code> <p>Standard deviation (for Gaussian) or half-width (for uniform) of noise to add to each point. Defaults to 0.0 (no noise).</p> <code>0.0</code> <code>noise_kind</code> <code>Literal['gaussian', 'uniform']</code> <p>Type of noise distribution to use if <code>noise_std &gt; 0</code>. Defaults to \"gaussian\".</p> <code>'gaussian'</code> <code>seed</code> <code>int</code> <p>Random seed for reproducibility. If None, randomness is not seeded.</p> <code>None</code> <p>Returns:</p> Type Description <code>tensor</code> <p>torch.Tensor: A tensor of shape (n_samples, 2) containing the sampled 2D points.</p>"},{"location":"reference/synthetic_data_generators/#flooder.synthetic_data_generators.generate_noisy_torus_points_3d","title":"generate_noisy_torus_points_3d","text":"<pre><code>generate_noisy_torus_points_3d(\n    n=1000,\n    R: float = 3.0,\n    r: float = 1.0,\n    noise_std: float = 0.02,\n    seed: int = None,\n) -&gt; torch.tensor\n</code></pre> <p>Generate 3D points on a torus with added Gaussian noise.</p> <p>Points are uniformly sampled on the surface of a torus defined by a major radius <code>R</code> and a minor radius <code>r</code>. Gaussian noise with standard deviation <code>noise_std</code> is added to each point independently in x, y, and z dimensions.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of points to generate. Defaults to 1000. R (float, optional): Major radius of the torus (distance from the center of the tube to the center of the torus). Must be positive. Defaults to 3.0.</p> <code>1000</code> <code>r</code> <code>float</code> <p>Minor radius of the torus (radius of the tube). Must be positive. Defaults to 1.0.</p> <code>1.0</code> <code>noise_std</code> <code>float</code> <p>Standard deviation of the Gaussian noise added to the points. Defaults to 0.02.</p> <code>0.02</code> <code>seed</code> <code>int</code> <p>Random seed for reproducibility. If None, randomness is not seeded.</p> <code>None</code> <p>Returns:</p> Type Description <code>tensor</code> <p>torch.Tensor: A tensor of shape (num_points, 3) containing the generated noisy 3D points.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; points = generate_noisy_torus_points_3d(\n        n=500, R=3.0, r=1.0, noise_std=0.05, seed=123)\n&gt;&gt;&gt; points.shape\ntorch.Size([500, 3])\n</code></pre>"},{"location":"reference/synthetic_data_generators/#flooder.synthetic_data_generators.generate_swiss_cheese_points","title":"generate_swiss_cheese_points","text":"<pre><code>generate_swiss_cheese_points(\n    n: int = 1000,\n    rect_min: tuple = (0.0, 0.0, 0.0),\n    rect_max: tuple = (1.0, 1.0, 1.0),\n    k: int = 6,\n    void_radius_range: tuple = (0.1, 0.2),\n    seed: int = None,\n    *,\n    device=\"cpu\",\n    batch_factor=4,\n) -&gt; Tuple[torch.Tensor, torch.Tensor, torch.Tensor]\n</code></pre> <p>Generate points in a high-dimensional rectangular region with randomly placed spherical voids, forming a \"Swiss cheese\" structure.</p> <p>Points are sampled uniformly within the bounding box defined by <code>rect_min</code> and <code>rect_max</code>, excluding k randomly positioned spherical voids with radii sampled from <code>void_radius_range</code>.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of points to generate. Defaults to 1000.</p> <code>1000</code> <code>rect_min</code> <code>tuple</code> <p>Minimum coordinates of the rectangular region. Defaults to a tuple of three zeros.</p> <code>(0.0, 0.0, 0.0)</code> <code>rect_max</code> <code>tuple</code> <p>Maximum coordinates of the rectangular region. Defaults to a tuple of three ones.</p> <code>(1.0, 1.0, 1.0)</code> <code>k</code> <code>int</code> <p>Number of spherical voids to generate. Defaults to 6.</p> <code>6</code> <code>void_radius_range</code> <code>Tuple[float, float]</code> <p>Range <code>(min_radius, max_radius)</code> for the void radii. Defaults to (0.1, 0.2).</p> <code>(0.1, 0.2)</code> <code>seed</code> <code>int</code> <p>Random seed for reproducibility. If None, randomness is not seeded.</p> <code>None</code> <code>device</code> <code>device</code> <p>Device to perform computations on. Defaults to 'cpu'.</p> <code>'cpu'</code> <code>batch_factor</code> <code>int</code> <p>How many candidates to shoot each round. Defaults to 4.</p> <code>4</code> <p>Returns:</p> Type Description <code>Tuple[Tensor, Tensor, Tensor]</code> <p>Tuple[torch.Tensor, torch.Tensor]: A tuple containing: - <code>points</code> (torch.Tensor): Tensor of shape (N, dim) with generated sample points. - <code>void_radii</code> (torch.Tensor): Tensor of shape (k,) with the radii of the voids.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; rect_min = (0.0, 0.0, 0.0)\n&gt;&gt;&gt; rect_max = (1.0, 1.0, 1.0)\n&gt;&gt;&gt; void_radius_range = (0.1, 0.2)\n&gt;&gt;&gt; k = 5\n&gt;&gt;&gt; points, _ = generate_swiss_cheese_points(\n...     1000000, rect_min, rect_max, k, void_radius_range\n... )\n&gt;&gt;&gt; points.shape\ntorch.Size([1000000, 3])\n</code></pre>"}]}